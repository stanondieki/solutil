const User = require('../models/User');
const ProviderService = require('../models/ProviderService');

/**
 * COMPREHENSIVE PROVIDER VALIDATION SYSTEM
 * Ensures provider discovery works across all categories
 */

/**
 * Validate and fix provider-service relationships
 */
async function validateAndFixProviderServices() {
  try {
    console.log('üîß PROVIDER-SERVICE VALIDATION INITIATED');
    
    const results = {
      providersChecked: 0,
      servicesCreated: 0,
      errors: [],
      categoryMapping: {},
      skillServiceGaps: []
    };

    // Get all approved providers
    const providers = await User.find({
      userType: 'provider',
      providerStatus: 'approved'
    }).select('name email providerProfile');

    console.log(`üìä Checking ${providers.length} approved providers...`);
    results.providersChecked = providers.length;

    for (const provider of providers) {
      const profile = provider.providerProfile || {};
      const skills = profile.skills || [];
      
      console.log(`\nüë§ Checking provider: ${provider.name}`);
      console.log(`   Skills: ${skills.join(', ') || 'None'}`);

      // Check existing services
      const existingServices = await ProviderService.find({
        providerId: provider._id,
        isActive: true
      });

      console.log(`   Existing services: ${existingServices.length}`);

      // Map skills to categories
      const skillCategories = mapSkillsToCategories(skills);
      
      for (const category of skillCategories) {
        // Track category mapping
        if (!results.categoryMapping[category]) {
          results.categoryMapping[category] = { providers: 0, services: 0 };
        }
        results.categoryMapping[category].providers++;

        // Check if provider has service in this category
        const hasService = existingServices.some(service => 
          service.category.toLowerCase().includes(category.toLowerCase())
        );

        if (!hasService) {
          console.log(`   ‚ö†Ô∏è Missing service for category: ${category}`);
          results.skillServiceGaps.push({
            provider: provider.name,
            skill: skills.filter(skill => {
              if (!skill) return false;
              const skillCategory = getCategoryForSkill(skill);
              return skillCategory && skillCategory.toLowerCase() === category.toLowerCase();
            })[0] || category,
            category: category
          });

          // Create missing service
          try {
            const filteredSkills = skills.filter(skill => {
              if (!skill) return false; // Handle null/undefined skills
              const skillCategory = getCategoryForSkill(skill);
              return skillCategory && skillCategory.toLowerCase() === category.toLowerCase();
            });

            const newService = await ProviderService.create({
              providerId: provider._id,
              title: `${category.charAt(0).toUpperCase() + category.slice(1)} Services by ${provider.name}`,
              description: `Professional ${category} services provided by ${provider.name}. Skilled in ${filteredSkills.join(', ') || category}.`,
              category: category,
              price: getDefaultPrice(category),
              priceType: 'fixed',
              duration: getDefaultDuration(category),
              location: profile.serviceAreas?.[0] || 'Nairobi',
              isActive: true,
              autoGenerated: true,
              createdFromValidation: true
            });

            console.log(`   ‚úÖ Created service: ${newService.title}`);
            results.servicesCreated++;
            results.categoryMapping[category].services++;
          } catch (error) {
            console.log(`   ‚ùå Failed to create service: ${error.message}`);
            results.errors.push({
              provider: provider.name,
              category: category,
              error: error.message
            });
          }
        } else {
          results.categoryMapping[category].services++;
        }
      }
    }

    // Final summary
    console.log('\nüìã VALIDATION SUMMARY:');
    console.log(`   Providers checked: ${results.providersChecked}`);
    console.log(`   Services created: ${results.servicesCreated}`);
    console.log(`   Errors: ${results.errors.length}`);
    
    console.log('\nüìä CATEGORY DISTRIBUTION:');
    Object.entries(results.categoryMapping).forEach(([category, data]) => {
      console.log(`   ${category}: ${data.providers} providers, ${data.services} services`);
    });

    return results;

  } catch (error) {
    console.error('‚ùå Provider validation failed:', error);
    throw error;
  }
}

/**
 * Map skills to service categories
 */
function mapSkillsToCategories(skills) {
  const categories = new Set();
  
  (skills || []).forEach(skill => {
    if (skill && typeof skill === 'string') {
      const category = getCategoryForSkill(skill);
      if (category) {
        categories.add(category);
      }
    }
  });
  
  return Array.from(categories);
}

/**
 * Get category for a specific skill
 */
function getCategoryForSkill(skill) {
  if (!skill || typeof skill !== 'string') {
    return null;
  }
  
  const skillLower = skill.toLowerCase();
  
  // Electrical
  if (['electrical', 'electrician', 'wiring', 'lighting', 'electrical repair', 'electricity'].some(keyword => 
    skillLower.includes(keyword))) {
    return 'electrical';
  }
  
  // Plumbing
  if (['plumbing', 'plumber', 'pipe', 'water', 'drainage', 'sewage'].some(keyword => 
    skillLower.includes(keyword))) {
    return 'plumbing';
  }
  
  // Cleaning
  if (['cleaning', 'cleaner', 'housekeeping', 'janitorial', 'sanitization'].some(keyword => 
    skillLower.includes(keyword))) {
    return 'cleaning';
  }
  
  // Carpentry
  if (['carpentry', 'carpenter', 'woodwork', 'furniture', 'cabinet', 'joinery'].some(keyword => 
    skillLower.includes(keyword))) {
    return 'carpentry';
  }
  
  // Painting
  if (['painting', 'painter', 'decoration', 'coat'].some(keyword => 
    skillLower.includes(keyword))) {
    return 'painting';
  }
  
  // Gardening
  if (['gardening', 'gardener', 'landscaping', 'lawn', 'garden', 'horticulture'].some(keyword => 
    skillLower.includes(keyword))) {
    return 'gardening';
  }
  
  // Moving
  if (['moving', 'mover', 'relocation', 'transport', 'logistics', 'packing'].some(keyword => 
    skillLower.includes(keyword))) {
    return 'moving';
  }
  
  return null;
}

/**
 * Get default pricing for categories
 */
function getDefaultPrice(category) {
  const priceMap = {
    'electrical': 3500,
    'plumbing': 3000,
    'cleaning': 2500,
    'carpentry': 4000,
    'painting': 3000,
    'gardening': 2000,
    'moving': 5000
  };
  
  return priceMap[category] || 3000;
}

/**
 * Get default duration for categories
 */
function getDefaultDuration(category) {
  const durationMap = {
    'electrical': 180, // 3 hours
    'plumbing': 120,   // 2 hours
    'cleaning': 240,   // 4 hours
    'carpentry': 360,  // 6 hours
    'painting': 480,   // 8 hours
    'gardening': 180,  // 3 hours
    'moving': 480      // 8 hours
  };
  
  return durationMap[category] || 120;
}

/**
 * Ensure all major categories have providers
 */
async function ensureCategoryProviders() {
  try {
    console.log('üéØ ENSURING CATEGORY COVERAGE');
    
    const majorCategories = [
      'electrical', 'plumbing', 'cleaning', 
      'carpentry', 'painting', 'gardening', 'moving'
    ];
    
    const results = {};
    
    for (const category of majorCategories) {
      console.log(`\nüîç Checking ${category} category...`);
      
      // Check services
      const services = await ProviderService.find({
        category: new RegExp(category, 'i'),
        isActive: true
      }).populate('providerId');
      
      // Check skill-based providers
      const skillProviders = await User.find({
        userType: 'provider',
        providerStatus: 'approved',
        'providerProfile.skills': new RegExp(category, 'i')
      });
      
      results[category] = {
        activeServices: services.length,
        serviceProviders: services.map(s => s.providerId?.name || 'Unknown'),
        skillProviders: skillProviders.length,
        skillProviderNames: skillProviders.map(p => p.name),
        coverage: services.length > 0 ? 'Good' : skillProviders.length > 0 ? 'Partial' : 'Poor'
      };
      
      console.log(`   Services: ${services.length}`);
      console.log(`   Skill providers: ${skillProviders.length}`);
      console.log(`   Coverage: ${results[category].coverage}`);
    }
    
    return results;
    
  } catch (error) {
    console.error('‚ùå Category coverage check failed:', error);
    throw error;
  }
}

module.exports = {
  validateAndFixProviderServices,
  ensureCategoryProviders,
  mapSkillsToCategories,
  getCategoryForSkill
};